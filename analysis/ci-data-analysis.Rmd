---
title: "Analysis of the Collective Intelligence Dataset"
output: pdf_document
data: March 25, 2020
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Data preparation

For this analysis, we are using a pre-processed dataset from Prof. de la Haye's lab experiment. This dataset has multiple types of networks including: influence, dislike, advice seeking, leadership, and trust. We will center the analysis on the advice seeking network.

# Testing homophily on gender

We will test the following hypothesis:

1. $\theta_{nodematch(female)} = 0$

We will estimate different models for this:

1. CUG test on U|MAN framework

2. ERGM including transitive triads as part of the model

```{r loading-data, echo = FALSE}
load("../data/model_data.rda")
net <- NETWORKS$advice

# Removing cases with missing
net <- net[which(!(as.integer(names(net)) %in% as.integer(miss$Female)))]
# net <- net[nvertex(net) > 3]
```

We now show the results of each approach.

## CUG test

```{r cug-test, cache = TRUE}
library(sna)
library(ergmito)

# Generating a sample
tester <- function(net, n = 100) {
  # Storing the vector of relevant attributes
  female_attrs <- get.vertex.attribute(net, attrname = "Female")
  
  stats_obs <- dyad.census(net)
  
  # Generating the random sample
  dat <- rguman(
    n, nv = nvertex(net),
    mut = stats_obs[,"Mut"],
    asym = stats_obs[,"Asym"],
    null = stats_obs[,"Null"],
    method = "exact"
    )
  
  ans <- vector("list", n)
  for (i in seq_along(ans)) {
    
    ans[[i]] <- network(dat[i, , ], vertex.attr = list(Female = female_attrs))
    
  }
  
  counts <- count_stats(ans ~ nodematch("Female"))
  obs    <- summary(net ~ nodematch("Female"))[1]
  cbind(
    obs  = summary(net ~ nodematch("Female"))[1],
    mean = mean(counts[,1]),
    p_lt = mean(obs < counts[,1]),
    p_eq = mean(obs == counts[,1]),
    p_gt = mean(obs > counts[,1])
  )
}

cug_test_ans <- do.call(
  rbind,
  lapply(net, tester, n = 500)
  )
```

Performing the CUG test gives not very encouraging results as only two of the analyzed networks showed a significant difference in the number of homophilic ties with respect to the the null.

```{r cug-test-print}
# How many are different
table(cug_test_ans[,4] <= .1)
```

## Using ergmito

In the case of little ergms, we will fit the following models:

1. edgecount and homophily on gender,

2. Same as 1. but including transitive triads

Besides these specifications (which can already be fitted in the `ergm` package), we will try a few others that cannot be implemented directly in the `ergm` package (nor in PNet):

3. Same as 2. but including Krivitsky, Handcock, and Morris (2011) offset term. Notice that the offset here will vary as a function of the network size, meaning that we cannot any longer use the blockdiagonal version of the model in the `ergm` package since the offset term cannot be specified by block.

4. Same as 2. but adding an interaction term with network size (so we assume linear effect)


```{r ergm}
library(ergmito)

# Available in ERGM
net_baseline <- ergmito(net ~ edges + ttriad)

net_struct   <- ergmito(net ~ edges + ttriad + nodematch("Female"))

# Not possible in the current implementation

# Krivitsky et al offset for pooled-data model
net_offset_kriv <- ergmito(
  net ~ edges + ttriad + nodematch("Female"),
  model_update = ~ . + offset(I(edges * log(1/n)))
  )

# Arbitrary models: Interaction term with a function of size
net_struct_sqrt <- ergmito(
  net ~ edges + ttriad + nodematch("Female"),
  model_update = ~ . + I(nodematch.Female * log(n))
  )

# Desity per size
net_struct_log <- ergmito(
  net ~ edges + ttriad + nodematch("Female"),
  model_update = ~ . + I(nodematch.Female * log(n)) + offset(I(edges * log(1/n)))
  )

# Interaction with offset
net_struct_log_offset <- ergmito(
  net ~ edges + ttriad + nodematch("Female"),
  model_update = ~ . + offset(I(nodematch.Female * log(n))) + offset(I(edges * log(1/n)))
  )

```

Here are the results

```{r tabulation, results='asis'}
texreg::texreg(
  list(
    net_baseline,
    net_struct,
    net_offset_kriv,
    net_struct_sqrt,
    net_struct_log,
    net_struct_log_offset
  ),
  reorder.coef = c(1:3, 5, 4, 6),
  groups = list("Regular terms" = c(1:4), Offset = c(5:6))
)
```

## Mixed effects model

In the case of the mixed effects model, we are assuming that:

a. There is a baseline homophily effect

b. There is a size-specific homophily effect

c. The size-specific effect are independent draws from a normal with mean $\mu$ and sd one. $\mu$ is distributed standard-normal.

We will fit this model using the `fmcmc` R package. The fitting is done using MCMC with Adaptive Metropolis:

```{r mcmc-fit, cache = TRUE}
library(fmcmc)

# Generating objective function using the ergmito_formulae
model <- ergmito_formulae(
  net[nvertex(net) > 3] ~ edges + ttriad + nodematch("Female"),
  model_update = ~ . - edges + 
    I(nodematch.Female * log(n)) + 
    I(edges * (n == 3)) +
    I(edges * (n == 4)) +
    I(edges * (n == 5))
  )

# Setting up the objective
p_names  <- c(model$term_names)
re_names <- c(sprintf("I(edges * (n == %d))", 3:5))
f <- function(p) {
  
  model$loglik(p[p_names]) + 
    sum(dnorm(p[re_names], mean = p["mu"], log = TRUE)) +
    dnorm(p["mu"], log = TRUE)
  
}

# Fitting the model
set.seed(123)
init <- rep(0, length(p_names) + 1)
names(init) <- c(p_names, "mu")
ans <- MCMC(
  initial = init,
  fun     = f,
  nsteps  = 8000,
  kernel  = kernel_am(warmup = 1000, eps = 1e-2),
  thin    = 10,
  burnin  = 2000,
  nchains = 2
  )

```

Here is the resulting distribution


```{r mcmc-plot, echo = FALSE}
dist <- do.call(rbind, ans)
dist <- apply(dist, 2, quantile, probs = c(.025, .5, .975))

op <- par(mar = par()$mar + c(0,6,0,0))
plot(
  x = dist[2,], y = 1:ncol(dist), xlim = extendrange(dist, f = .15), yaxt = "n",
  ylab = "",
  xlab = "Coefficient",
  pch = 19,
  main = "95% CI for the parameter estimates using MCMC"
  )
arrows(
  x0 = dist[1, ],
  y0 = 1:ncol(dist),
  x1 = dist[3,],
  y1 = 1:ncol(dist),
  lwd = 2,
  code= 3,
  angle = 90,
  length = .08
)
axis(side = 2, at = 1:ncol(dist), labels = colnames(dist), las =2)
par(op)
abline(v = 0, lwd = 2, lty = 2, col = "red")
```

