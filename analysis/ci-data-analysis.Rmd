---
title: "Analysis of the Collective Intelligence Dataset"
output: pdf_document
data: March 25, 2020
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

# Data preparation

For this analysis, we are using a pre-processed dataset from Prof. de la Haye's lab experiment. This dataset has multiple types of networks including: influence, dislike, advice seeking, leadership, and trust. We will center the analysis on the advice seeking network.

# Testing homophily on gender

We will test the following hypothesis:

1. $\theta_{nodematch(female)} = 0$

We will estimate different models for this:

1. CUG test on U|MAN framework

2. ERGM including transitive triads as part of the model

```{r loading-data, echo = FALSE}
library(ergmito)
load("../data/model_data.rda")
net <- NETWORKS$advice

# Removing cases with missing
net <- net[which(!(as.integer(names(net)) %in% as.integer(miss$Female)))]
net <- net[nvertex(net) > 3]
```

We now show the results of each approach.

## CUG test

Let's first see how does the MAN distribution looks:

```{r man-dist, fig.cap="Distribution of the dyadic-census for the observed data."}
man_dist <- lapply(net, sna::dyad.census)
man_dist <- do.call(rbind, man_dist)
op <- par(mfrow = c(2,2), mar = par()$mar * c(1, 1, .25, 1))
for (i in colnames(man_dist))
  MASS::truehist(man_dist[,i], main = '', xlab = i)
par(op)
```

For the CUG test, we are using our own implementation based on the rguman function implemented on statnet's sna R package, which implemens a U|MAN sampler. The test was applied a the network level, this is, `r nnets(net)` tests. Since the variability of the data under the U|MAN distribution is rather small, we reduced the test statistic to see what we observe the same count of homophilic ties between the null and the observed network.

```{r cug-test, cache = TRUE, echo = FALSE}
library(sna)
library(ergmito)

# Generating a sample
sample_gen <- function(net, n = 100) {
  # Storing the vector of relevant attributes
  female_attrs <- get.vertex.attribute(net, attrname = "Female")
  
  stats_obs <- dyad.census(net)
  
  # Generating the random sample
  dat <- rguman(
    n, nv  = nvertex(net),
    mut    = stats_obs[,"Mut"],
    asym   = stats_obs[,"Asym"],
    null   = stats_obs[,"Null"],
    method = "exact"
    )
  
  ans <- vector("list", n)
  for (i in seq_along(ans)) {
    
    ans[[i]] <- network(dat[i, , ], vertex.attr = list(Female = female_attrs))
    
  }
  
  count_stats(ans ~ nodematch("Female"))
}

# Generating 100 samples per network
set.seed(1231)
cug_samples <- parallel::mclapply(net, sample_gen, n = 200, mc.cores = 4L)
cug_samples <- do.call(cbind, cug_samples)

# Retrieving the ids to draw from each case
idx <- replicate(nnets(net), sample.int(200, 5000, TRUE), simplify = FALSE)
idx <- do.call(cbind, idx)

# Computing the average nodematch("Female")
null_dist <- apply(idx, 1, function(i) mean(cug_samples[cbind(i, 1L:31L)]))

# Observed average
obs <- mean(count_stats(net ~ nodematch("Female")))

# Density plot
op <- par(mar = par("mar") * c(1, 1, .2, .2))
plot(
  density(null_dist),
  xlab = "Ave. # of homofilic ties on gender",
  main = ""
  )
abline(v = obs, lty = 2, lwd = 2)
text(
  x = obs, y = .25,
  labels = sprintf("Avg. # observed in \nthe data: %.2f.", obs),
  pos = 4)
par(op)
```

The distribution of the test statistic follows:

```{r cug-results, echo = FALSE, fig.cap="Proportion of the null equal to the observed statistic, per network. The null was generated by retrieving 500 samples from a U|MAN distribution."}
barplot(
  unname(cug_test_ans[,"p_eq"]), col = nvertex(net), xlab = "",
  ylab = "Proportion equal to the observed"
  )
colors_sizes <- sort(unique(nvertex(net)))
legend(
  "topright", col = colors_sizes, legend = colors_sizes, pch = 15,
  title = "Network sizes", bty = "n"
  )
abline(h = .1, lwd = 2, lty = 2)
```

Performing the CUG test gives not very encouraging results as only two of the analyzed networks showed a significant difference in the number of homophilic ties with respect to the the null.

## Using ergmito

In the case of little ergms, we will fit the following models:

1. edgecount and transitivity,

2. Same as 1. but including homophily on gender

Besides these specifications (which can already be fitted in the `ergm` package), we will try a few others that cannot be implemented directly in the `ergm` package (nor in PNet):

3. Same as 2. but including Krivitsky, Handcock, and Morris (2011) offset term. Notice that the offset here will vary as a function of the network size, meaning that we cannot any longer use the blockdiagonal version of the model in the `ergm` package since the offset term cannot be specified by block.

4. Same as 2. but adding an interaction term with log of size of the network.

5. Same as 4. but adding Krivitsky's offset.

6. Same as 5. but now the interaction with log(size) is an offset term.

The next table shows the results

```{r ergm-baseline, cache = TRUE, echo = FALSE}
# Available in ERGM
net_baseline00 <- ergmito(net ~ edges + ttriad)
net_baseline01 <- ergmito(net ~ edges + ttriad, model_update = ~ . + offset(I(edges * log(1/n))))
net_baseline02 <- ergmito(net ~ edges + ttriad, model_update = ~ . + I(edges * (n == 5)))
net_baseline03 <- ergmito(net ~ edges + ttriad, model_update = ~ . + I(ttriple * (n == 5)))
net_baseline04 <- ergmito(net ~ edges + ttriad, model_update = ~ . + I(ttriple * (n == 5)) + I(edges * (n == 5)))
net_baseline02_bs <- ergmito_boot(net_baseline02, R = 1000)
```

First, we fitted models using structural terms only, we tried using edgecounts, transitive triads, interaction terms with size indicator, and using Krivitsky et al. (2011) offset term. Table \autoref{tab:ergm-baseline} shows the results.

```{r ergm-baseline-table, cache = FALSE, echo = FALSE}
texreg::texreg(
  list(
    net_baseline00,
    net_baseline01,
    net_baseline02,
    net_baseline03,
    net_baseline04,
    net_baseline02_bs
  ),
  single.row   = TRUE,
  include.convergence = FALSE,
  reorder.coef = c(1,2,4,5,3),
  caption      = paste(
    "Structural models. Model 2 includes Krivitsky et al (2011) offset term.",
    "Besides of the common GOF statistics, the table includes the number of",
    "networks used, elapsed time to fit the model, and, in the case of Model",
    "6 which is a bootstrapped version of Model 3, number of replicates fitted",
    "and included in the bootstrap variance estimate."
  ),
  label = "tab:ergm-baseline"
  )
```

Models one through five are regular models fitted using MLE, while Model six is a bootstrapped version of Model three. Of the five different specifications tested, Model three has the best fit overal (according to log-likelihood, AIC, and BIC). The only exception when comparing models on Log-likelihood is regarding Model five, yet, besides from the fact that two of it's terms are not significant, a Likelihood Ratio Test fails to reject the null of Model three been the reference model. After selecting the later as the baseline model, we calculated the bootstrapped standard errors by resampling the 31 networks 1,000 times. While we do not observe significant differences on the standard errors (+/- 0.01), what is remarkable of this excersice is the fact that: (a) the five models were fitted in less than a second, and (b) the 1,000 samples bootstrap took less than 10 seconds to be completed; something that cannot be acomplished with MC-MLE, at least in the current state of the affairs.

We now take this reference model and use it with different specifications to test the hypothesis $H_0:\theta_{\text{homophily(gender)}} \neq 0$.

```{r ergm-homophily}
# Arbitrary models: Interaction term with a function of size
net_struct_baseline01 <- ergmito(
  net ~ edges + ttriad + nodematch("Female"),
  model_update = ~ . + I(edges * (n == 5))
)

# net_struct_baseline01 <- ergmito(
#   net ~ edges + ttriad + nodematch("Female"),
#   model_update = ~ . + I(edges * (n == 5)) + I(nodematch.Female * (n == 5))
# )

net_struct_baseline02 <- ergmito(
  net ~ edges + ttriad + nodematch("Female"),
  model_update = ~ . + I(edges * (n == 5)) + I(sqrt(nodematch.Female))
)

net_struct_baseline03 <- ergmito(
  net ~ edges + ttriad + nodematch("Female"),
  model_update = ~ . + I(edges * (n == 5)) + I((nodematch.Female) ^ 2)
)

net_struct_baseline04 <- ergmito(
  net ~ edges + ttriad + nodematch("Female") + nodeocov("Female"),
  model_update = ~ . + I(edges * (n == 5))
)

net_struct_baseline05 <- ergmito(
  net ~ edges + ttriad + nodematch("Female") + nodeicov("Female"),
  model_update = ~ . + I(edges * (n == 5))
)

net_struct_baseline04_bs <- ergmito_boot(net_struct_baseline04, R = 1000)

texreg::screenreg(
  list(
    net_struct_baseline01,
    net_struct_baseline02,
    net_struct_baseline03,
    net_struct_baseline04,
    net_struct_baseline05,
    net_struct_baseline04_bs
  ),
  single.row   = TRUE,
  include.convergence = FALSE,
)
```


```{r tabulation, results='asis'}
texreg::screenreg(
  list(
    net_baseline,
    net_struct,
    net_offset_kriv,
    net_struct_inter,
    net_struct_sqrt,
    net_struct_pow2,
    net_struct_over_n,
    net_struct_outdeg,
    net_struct_indeg,
    net_struct_outdeg_bs
  ),
  reorder.coef = c(1:3, 9:10, 5:8, 4),
  include.convergence = FALSE,
  groups = list("Regular terms" = c(1:5), "Complex terms and offset" = c(6:10))
)
```

Notice that for the last model, in ergmito the implementation is rather straight forward:

```r
ergmito(
  model        = net ~ edges + ttriad + nodematch("Female"),
  model_update = ~ . +
    offset(I(nodematch.Female * log(n))) +
    offset(I(edges * log(1/n)))
  )
```

## Mixed effects model

In the case of the mixed effects model, we are assuming that:

a. There is a baseline homophily effect

b. There is a size-specific homophily effect

c. The size-specific effect are independent draws from a normal with mean $\mu$ and sd one. $\mu$ is distributed standard-normal.

We will fit this model using the `fmcmc` R package. The fitting is done using MCMC with Adaptive Metropolis:

```{r mcmc-fit, cache = TRUE}
library(fmcmc)

# Generating objective function using the ergmito_formulae
ans_ergmito0 <- ergmito(
  net ~ edges + ttriad + nodematch("Female"),
  model_update = ~ . - edges + 
    I(edges * (n == 4)) +
    I(edges * (n == 5))
  )

ans_ergmito1 <- ergmito(
  net ~ edges + ttriad + nodematch("Female"),
  model_update = ~ . - edges + 
    offset(I(edges) * log(1/n))
  )

lmtest::lrtest(ans_ergmito1, ans_ergmito0)
# Likelihood ratio test
# 
# Model 1: net ~ ttriad + nodematch("Female") + offset(I(edges) * log(1/n))
# Model 2: net ~ ttriad + nodematch("Female") + I(edges * (n == 4)) + I(edges * 
#     (n == 5)) + offset(I(edges) * log(1/n))
#   #Df  LogLik Df Chisq Pr(>Chisq)    
# 1   2 -368.78                        
# 2   4 -315.63  2 106.3  < 2.2e-16 ***
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# 

# Setting up the objective
p_names  <- c(ans_ergmito0$formulae$term_names)
re_names <- c(sprintf("I(edges * (n == %d))", 4:5))
f <- function(p) {
  
  S <- diag(2)
  S[c(2, 3)] <- p["cov"]
  # S[c(1, 4)] <- c(p["s_4"], p["s_5"])
  
  val <- ans_ergmito0$formulae$loglik(p[p_names]) + 
    mvtnorm::dmvnorm(p[re_names], mean = rep(p["mu"], 2), sigma = S, log = TRUE) +
    dnorm(p["mu"], log = TRUE)
  
  if (!is.finite(val))
    return(-1e100)
  
  val
  
}

# Fitting the model
set.seed(123)
init <- rep(0, length(p_names) + 2)
names(init) <- c(p_names, "mu", "cov") #, "s_4", "s_5")
# init[c("s_4", "s_5")] <- 5
ans <- MCMC(
  initial = init,
  fun     = f,
  nsteps  = 4000,
  kernel  = kernel_am(warmup = 1000, eps = 1e-2), #, lb = c(rep(-20, length(p_names) + 2), .0001, .0001)),
  thin    = 10,
  burnin  = 2000,
  nchains = 2
  )

```

Here is the resulting distribution


```{r mcmc-plot, echo = FALSE}
dist <- do.call(rbind, ans)
dist <- apply(dist, 2, quantile, probs = c(.025, .5, .975))

op <- par(mar = par()$mar + c(0,6,0,0))
plot(
  x = dist[2,], y = 1:ncol(dist), xlim = extendrange(dist, f = .15), yaxt = "n",
  ylab = "",
  xlab = "Coefficient",
  pch = 19,
  main = "95% CI for the parameter estimates using MCMC"
  )
arrows(
  x0 = dist[1, ],
  y0 = 1:ncol(dist),
  x1 = dist[3,],
  y1 = 1:ncol(dist),
  lwd = 2,
  code= 3,
  angle = 90,
  length = .08
)
axis(side = 2, at = 1:ncol(dist), labels = colnames(dist), las =2)
par(op)
abline(v = 0, lwd = 2, lty = 2, col = "red")
```

```{r solving-w-optim}
ans_optim <- optim(init, fn = f, control = list(fnscale = -1, maxit = 1000), hessian = TRUE)
```

